<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Cookie Clicker</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background-color: #f5f0e6;
            color: #5a3921;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            text-align: center;
        }
        
        .auto-clicker-cursor {
          position: absolute;
          width: 50px;
          height: 50px;
          background: url('pointer_finger.png') no-repeat center center; /* Your pointer image */
          background-size: contain;
          pointer-events: none;
          transform-origin: center center; /* Helpful for rotation */
        }


        @keyframes pokeCookie {
            0%   { transform: translate(-50%, -50%) rotate(0deg); }
            25%  { transform: translate(-50%, -40%) rotate(0deg); }
            50%  { transform: translate(-50%, -50%) rotate(0deg); }
            75%  { transform: translate(-50%, -40%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(0deg); }
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        
        @media (min-width: 768px) {
            .game-container {
                flex-direction: row;
                align-items: flex-start;
            }
        }
        
        .game-section {
            background-color: #fff;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin: 10px;
            flex: 1;
        }
        
        .pastry-section {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .pastry-container {
            position: relative;
            cursor: pointer;
            transition: transform 0.05s;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .pastry-container:active {
            transform: scale(0.97);
        }
        
        .pastry {
            width: 300px;  /* increased size */
            height: 300px; /* increased size */
            background-color: #c17e40;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            box-shadow: inset 0 0 10px 5px #8c5e2b;
        }
        
        .pastry::before {
            content: "";
            position: absolute;
            width: 90%;
            height: 90%;
            background-color: #d9a05c;
            border-radius: 50%;
            box-shadow: inset 0 0 5px 3px #8c5e2b;
        }
        /* Grandma Animation */
        .grandma-animation {
            width: 50px;
            height: 50px;
            background-image: url('grandma.png'); /* Replace with your grandma image URL */
            background-size: cover;
            position: absolute;
            pointer-events: none;
            animation: grandmaTouch 1.5s forwards;
        }

        @keyframes grandmaTouch {
            0%   { transform: translate(-150%, 0) scale(0.5); opacity: 0; }
            50%  { transform: translate(0, 0) scale(1); opacity: 1; }
            100% { transform: translate(0, -50%) scale(1); opacity: 0; }
        }

        /* Farm Animation */
        .farm-active {
            background-image: url('farm-background.png'); /* Replace with your farm background image URL */
            background-size: cover;
            transition: background 1.5s ease;
        }
        
        .chip {
            position: absolute;
            background-color: #3a250e;
            border-radius: 50%;
            width: 20px;
            height: 20px;
        }
        
        .chip:nth-child(1) { top: 25%; left: 35%; }
        .chip:nth-child(2) { top: 35%; right: 35%; }
        .chip:nth-child(3) { bottom: 25%; left: 45%; }
        .chip:nth-child(4) { bottom: 35%; right: 30%; }
        .chip:nth-child(5) { top: 55%; left: 25%; }
        .chip:nth-child(6) { bottom: 35%; right: 45%; }
        
        .pastry-counter {
            font-size: 24px;
            font-weight: bold;
            margin: 20px 0;
        }
        
        .cps-counter {
            font-size: 16px;
            margin-bottom: 20px;
        }
        
        .upgrades-section, .buildings-section, .leaderboard-section {
            max-height: 500px;
            overflow-y: auto;
        }
        
        .upgrade-item, .building-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin: 10px 0;
            background-color: #f9f2e7;
            border-radius: 5px;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .upgrade-item:hover, .building-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.1);
        }
        
        .upgrade-info, .building-info {
            text-align: left;
        }
        
        .upgrade-name, .building-name {
            font-weight: bold;
        }
        
        .upgrade-desc, .building-desc {
            font-size: 12px;
            color: #666;
        }
        
        .upgrade-button, .building-button {
            background-color: #8c5e2b;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .upgrade-button:hover, .building-button:hover {
            background-color: #6a451f;
        }
        
        .upgrade-button:disabled, .building-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        
        .achievement {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.5s;
        }
        
        .notification-container {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
        }
        
        .notification {
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            margin-bottom: 10px;
            border-radius: 5px;
            animation: fadeIn 0.3s, fadeOut 0.3s 2.7s;
            opacity: 0;
            animation-fill-mode: forwards;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }
        
        .player-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
        }
        
        .player-name {
            font-weight: bold;
        }
        
        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            padding: 8px;
            margin: 5px 0;
            background-color: #f9f2e7;
            border-radius: 5px;
        }
        
        .leaderboard-rank {
            font-weight: bold;
            margin-right: 10px;
        }
        
        .leaderboard-name {
            flex-grow: 1;
            text-align: left;
        }
        
        .leaderboard-pastries {
            font-weight: bold;
        }
        
        .login-container {
            max-width: 400px;
            margin: 100px auto;
            padding: 20px;
            background-color: #fff;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        
        .login-input {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        
        .login-button {
            width: 100%;
            padding: 10px;
            background-color: #8c5e2b;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        
        .login-button:hover {
            background-color: #6a451f;
        }
        
        .event-notification {
            background-color: #ff9800;
            color: white;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            text-align: center;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        @keyframes fadeUp {
                    0% { opacity: 1; transform: translateY(0); }
                    100% { opacity: 0; transform: translateY(-50px); }
        }

    </style>
</head>
<body>
    <div id="login-screen" class="login-container">
        <h2>Multiplayer Cookie Clicker</h2>
        <p>Enter your name to start playing!</p>
        <input type="text" id="player-name-input" class="login-input" placeholder="Your name">
        <button id="login-button" class="login-button">Start Game</button>
    </div>
    
    <div id="game-screen" style="display: none;">
        <h1>Multiplayer Cookie Clicker</h1>
        <div class="player-info">
            <span class="player-name" id="player-name">Player</span>
            <button id="save-button" class="upgrade-button">Save Game</button>
        </div>
        
        <div class="game-container">
            <div class="game-section pastry-section">
                <div class="pastry-container" id="pastry-clicker">
                    <div class="pastry">
                        <div class="chip"></div>
                        <div class="chip"></div>
                        <div class="chip"></div>
                        <div class="chip"></div>
                        <div class="chip"></div>
                        <div class="chip"></div>
                        <div class="auto-clicker-cursor" id="autoClickerCursor" style="display: none;"></div>
                    </div>
                </div>
                <div class="pastry-counter" id="pastry-counter">0 cookies</div>
                <div class="cps-counter" id="cps-counter">0 per second</div>
                <div id="event-container"></div>
            </div>
            
            <div class="game-section upgrades-section">
                <h2>Upgrades</h2>
                <div id="upgrades-container"></div>
            </div>
            
            <div class="game-section buildings-section">
                <h2>Buildings</h2>
                <div id="buildings-container"></div>
            </div>
            
            <div class="game-section leaderboard-section">
                <h2>Leaderboard</h2>
                <div id="leaderboard-container"></div>
            </div>
        </div>
    </div>
    
    <div id="achievement" class="achievement"></div>
    <div id="notification-container" class="notification-container"></div>

    <script type="module">
        // Import Firebase modules
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.3.1/firebase-app.js';
        import { getDatabase, ref, set, onValue, update, get, child } from 'https://www.gstatic.com/firebasejs/10.3.1/firebase-database.js';

        // Your Firebase configuration
        // NOTE: In a real app, you would need to replace this with your actual Firebase config
        const firebaseConfig = {
            apiKey: "AIzaSyD9CTMnRQaaHJwZ7Nh8BXyqTSauNI-55no",
            authDomain: "cookie-clicker-game-d6d0a.firebaseapp.com",
            databaseURL: "https://cookie-clicker-game-d6d0a-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "cookie-clicker-game-d6d0a",
            storageBucket: "cookie-clicker-game-d6d0a.firebasestorage.app",
            messagingSenderId: "232493349168",
            appId: "1:232493349168:web:860392bc64687b8865f0f5"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);

        // Game state
        let gameState = {
            cookies: 0,
            cookiesPerClick: 1,
            cookiesPerSecond: 0,
            autoClickSpeed: 0,
            upgrades: {},
            buildings: {},
            achievements: [],
            lastSaved: Date.now(),
            playerName: "",
            playerId: "",
            totalClicks: 0,
            autoClickAccumulator: 0
        };

        // Game elements
        const cookieCounter = document.getElementById('pastry-counter');
        const cpsCounter = document.getElementById('cps-counter');
        const cookieClicker = document.getElementById('pastry-clicker');
        const upgradesContainer = document.getElementById('upgrades-container');
        const buildingsContainer = document.getElementById('buildings-container');
        const achievementElement = document.getElementById('achievement');
        const notificationContainer = document.getElementById('notification-container');
        const leaderboardContainer = document.getElementById('leaderboard-container');
        const playerNameElement = document.getElementById('player-name');
        const loginScreen = document.getElementById('login-screen');
        const gameScreen = document.getElementById('game-screen');
        const playerNameInput = document.getElementById('player-name-input');
        const loginButton = document.getElementById('login-button');
        const saveButton = document.getElementById('save-button');
        const eventContainer = document.getElementById('event-container');

        // Game configuration
        const UPGRADES = [
            { id: 'cursor1', name: 'Cursor Level 1', description: '+1 cookie per click', cost: 50, effect: { cookiesPerClick: 1 }, requires: null },
            { id: 'cursor2', name: 'Cursor Level 2', description: '+2 cookies per click', cost: 200, effect: { cookiesPerClick: 2 }, requires: 'cursor1' },
            { id: 'cursor3', name: 'Cursor Level 3', description: '+3 cookies per click', cost: 500, effect: { cookiesPerClick: 3 }, requires: 'cursor2' },
            { id: 'autoclick1', name: 'Auto Clicker 1', description: 'Clicks automatically once every 10 seconds', cost: 100, effect: { autoClick: 0.1 }, requires: null },
            { id: 'autoclick2', name: 'Auto Clicker 2', description: 'Clicks automatically once every 5 seconds', cost: 300, effect: { autoClick: 0.2 }, requires: 'autoclick1' },
            { id: 'buildingBoost1', name: 'Building Boost 1', description: 'All buildings produce 50% more cookies', cost: 1000, effect: { buildingMultiplier: 1.5 }, requires: null },
            { id: 'buildingBoost2', name: 'Building Boost 2', description: 'All buildings produce 100% more cookies', cost: 5000, effect: { buildingMultiplier: 2 }, requires: 'buildingBoost1' },
        ];

        const BUILDINGS = [
            { id: 'grandma', name: 'Grandma', description: 'A nice grandma to bake cookies.', baseCost: 100, cookiesPerSecond: 0.5 },
            { id: 'farm', name: 'Farm', description: 'Grows cookie plants.', baseCost: 500, cookiesPerSecond: 2 },
            { id: 'mine', name: 'Mine', description: 'Mines cookie dough.', baseCost: 2000, cookiesPerSecond: 10 },
            { id: 'factory', name: 'Factory', description: 'Produces mass amounts of cookies.', baseCost: 10000, cookiesPerSecond: 50 },
            { id: 'bank', name: 'Bank', description: 'Generates cookies from interest.', baseCost: 50000, cookiesPerSecond: 250 },
        ];

        const ACHIEVEMENTS = [
            { id: 'firstClick', name: 'First Click', description: 'Click the cookie for the first time.', condition: (state) => state.clicks > 0, unlocked: false },
            { id: 'tenCookies', name: 'Cookie Beginner', description: 'Bake 10 cookies in total.', condition: (state) => state.cookies >= 10, unlocked: false },
            { id: 'hundredCookies', name: 'Cookie Apprentice', description: 'Bake 100 cookies in total.', condition: (state) => state.cookies >= 100, unlocked: false },
            { id: 'thousandCookies', name: 'Cookie Master', description: 'Bake 1,000 cookies in total.', condition: (state) => state.cookies >= 1000, unlocked: false },
            { id: 'millionCookies', name: 'Cookie Millionaire', description: 'Bake 1,000,000 cookies in total.', condition: (state) => state.cookies >= 1000000, unlocked: false },
            { id: 'firstGrandma', name: 'Grandma\'s Helper', description: 'Hire your first grandma.', condition: (state) => state.buildings.grandma && state.buildings.grandma.count > 0, unlocked: false },
            { id: 'tenGrandmas', name: 'Grandma\'s Army', description: 'Hire 10 grandmas.', condition: (state) => state.buildings.grandma && state.buildings.grandma.count >= 10, unlocked: false },
            { id: 'firstFarm', name: 'Farmer', description: 'Build your first farm.', condition: (state) => state.buildings.farm && state.buildings.farm.count > 0, unlocked: false },
        ];

        const EVENTS = [
            { id: 'cookieRain', name: 'Cookie Rain', description: 'Cookies are raining! Click the cookie for double cookies for the next 30 seconds!', duration: 30000, effect: { cookiesPerClickMultiplier: 2 } },
            { id: 'frenzyCookies', name: 'Cookie Frenzy', description: 'Cookie frenzy! All buildings produce 3x cookies for the next 20 seconds!', duration: 20000, effect: { buildingMultiplier: 3 } },
            { id: 'clickFrenzy', name: 'Click Frenzy', description: 'Click frenzy! Each click produces 7x cookies for the next 15 seconds!', duration: 15000, effect: { cookiesPerClickMultiplier: 7 } },
        ];

        let activeEvents = [];
        let totalClicks = 0;
        
        // Initialize the game
        function initGame() {
            // Set up event listeners
            cookieClicker.addEventListener('click', clickCookie);
            saveButton.addEventListener('click', saveGame);
            loginButton.addEventListener('click', login);
            
            // Still called every 1000ms (1 second)
            setInterval(updateCookiesPerSecond, 1000);
            setInterval(saveGame, 60000); // Auto-save every minute
            setInterval(checkAchievements, 5000);
            setInterval(triggerRandomEvent, 120000); // Random event every 2 minutes
            setInterval(updateLeaderboard, 10000);
            
            // Initialize upgrades and buildings
            initializeUpgrades();
            initializeBuildings();
            
            // Set up Firebase listeners
            listenForMultiplayerEvents();
        }

        // Log in and start game (updated for asynchronous load timing)
        function login() {
            const name = playerNameInput.value.trim();
            if (!name) {
                showNotification("Please enter a name to start playing!");
                return;
            }
            
            gameState.playerName = name;
            gameState.playerId = Date.now().toString(36) + Math.random().toString(36).substr(2);
            playerNameElement.textContent = name;
            
            // Load saved game and then show the game screen once loading is complete
            loadGame().then(() => {
                loginScreen.style.display = 'none';
                gameScreen.style.display = 'block';
                // Save initial state and welcome the player
                saveGame();
                showNotification(`Welcome, ${name}! Start clicking to earn cookies!`);
            }).catch((error) => {
                console.error("Error during game load:", error);
                // Even if load fails, proceed to game screen
                loginScreen.style.display = 'none';
                gameScreen.style.display = 'block';
                saveGame();
                showNotification(`Welcome, ${name}! Start clicking to earn cookies!`);
            });
        }

        // Click the cookie
        function clickCookie() {
            let clickValue = gameState.cookiesPerClick;
            activeEvents.forEach(event => {
                if (event.effect.cookiesPerClickMultiplier) {
                    clickValue *= event.effect.cookiesPerClickMultiplier;
                }
            });
            gameState.cookies += clickValue;
            console.log("Cookies after click:", gameState.cookies);

            // Increment click count in gameState
            gameState.totalClicks++; 

            updateCookieCounter();
            createClickAnimation(clickValue);
            checkAchievements();
        }

        // Initialize upgrades
        function initializeUpgrades() {
            // Clear the container first to refresh the display
            upgradesContainer.innerHTML = '';

            UPGRADES.forEach(upgrade => {
                // Initialize upgrade in game state if not exists
                if (!gameState.upgrades[upgrade.id]) {
                    gameState.upgrades[upgrade.id] = { purchased: false };
                }
                
                // Check prerequisite
                let requirementMet = true;
                if (upgrade.requires) {
                    requirementMet = gameState.upgrades[upgrade.requires] && gameState.upgrades[upgrade.requires].purchased;
                }
                
                // Only create the upgrade element if the requirement is met and it hasn't been purchased
                if (requirementMet && !gameState.upgrades[upgrade.id].purchased) {
                    const upgradeElement = document.createElement('div');
                    upgradeElement.className = 'upgrade-item';
                    upgradeElement.id = `upgrade-container-${upgrade.id}`;
                    upgradeElement.innerHTML = `
                        <div class="upgrade-info">
                            <div class="upgrade-name">${upgrade.name}</div>
                            <div class="upgrade-desc">${upgrade.description}</div>
                            <div class="upgrade-cost">${formatNumber(upgrade.cost)} cookies</div>
                        </div>
                        <button class="upgrade-button" id="upgrade-${upgrade.id}">Buy</button>
                    `;
                    upgradesContainer.appendChild(upgradeElement);
                    document.getElementById(`upgrade-${upgrade.id}`).addEventListener('click', () => purchaseUpgrade(upgrade.id));
                }
            });
            
            // After (re)creating upgrade elements, immediately update their button states
            updateButtons();
        }



        // Initialize buildings
        function initializeBuildings() {
            buildingsContainer.innerHTML = '';
            
            BUILDINGS.forEach(building => {
                // Initialize building in game state if not exists
                if (!gameState.buildings[building.id]) {
                    gameState.buildings[building.id] = { count: 0 };
                }
                
                const count = gameState.buildings[building.id].count;
                const cost = calculateBuildingCost(building.id);
                
                const buildingElement = document.createElement('div');
                buildingElement.className = 'building-item';
                buildingElement.innerHTML = `
                    <div class="building-info">
                        <div class="building-name">${building.name} (${count})</div>
                        <div class="building-desc">${building.description}</div>
                        <div class="building-production">Each produces ${formatNumber(calculateBuildingProduction(building.id))} cookies/sec</div>
                        <div class="building-cost">${formatNumber(cost)} cookies</div>
                    </div>
                    <button class="building-button" id="building-${building.id}" ${gameState.cookies < cost ? 'disabled' : ''}>Buy</button>
                `;
                buildingsContainer.appendChild(buildingElement);
                
                // Add event listener
                document.getElementById(`building-${building.id}`).addEventListener('click', () => purchaseBuilding(building.id));
            });
        }

        // Helper function to show the pointer
        function showAutoClickerCursor() {
            const pointerElem = document.getElementById('autoClickerCursor');
            if (pointerElem.style.display === 'none') {
                pointerElem.style.display = 'block';
                updatePointerPosition(); // Begin the continuous orbit
            }
        }

        // Global variables for pointer animation
        let pointerAngle = 0;          // Current angle in radians
        const rotationSpeed = 0.01;    // Radians per frame (adjust for faster/slower rotation)
        const pointerRadius = 130;     // Distance from the cookie center (adjust as needed)
        let currentPokeOffset = 0;     // Additional inward offset for poking (0 normally)

        // Declare a global flag at the top of your script:
        let isPointerAnimating = false;

        // Updated updatePointerPosition function remains unchanged:
        // ui.js - Updated updatePointerPosition function
        function updatePointerPosition() {
          const pointer = document.getElementById('autoClickerCursor');
          const pastry = document.querySelector('.pastry');
          if (!pointer || !pastry) {
            isPointerAnimating = false;
            return;
          }
          const pastryRect = pastry.getBoundingClientRect();
          const centerX = pastryRect.width / 2;
          const centerY = pastryRect.height / 2;
          const baseRadius = pastryRect.width / 2 + 20;
          const effectiveRadius = baseRadius - currentPokeOffset;
          const pointerX = centerX + effectiveRadius * Math.cos(pointerAngle);
          const pointerY = centerY + effectiveRadius * Math.sin(pointerAngle);
          pointer.style.left = (pointerX - pointer.offsetWidth / 2) + 'px';
          pointer.style.top = (pointerY - pointer.offsetHeight / 2) + 'px';
          const angleDeg = (pointerAngle * 180) / Math.PI + 270;
          pointer.style.transform = `rotate(${angleDeg}deg)`;
          pointerAngle += rotationSpeed;
          requestAnimationFrame(updatePointerPosition);
        }


        // Poke animation: temporarily move the pointer inward so it "touches" the cookie
        function pokeCookie() {
          // Set the poke offset (in pixels) to temporarily bring the pointer closer to the cookie
          currentPokeOffset = 20;
          
          // After 200ms, reset the poke offset so that the pointer returns to its normal orbit
          setTimeout(() => {
            currentPokeOffset = 0;
          }, 200);
        }


        // Purchase an upgrade
        // In your existing purchaseUpgrade function:
        function purchaseUpgrade(upgradeId) {
            console.log("Attempting to purchase upgrade:", upgradeId);
            const upgrade = UPGRADES.find(u => u.id === upgradeId);
            
            if (gameState.cookies >= upgrade.cost && !gameState.upgrades[upgradeId].purchased) {
                // Deduct cookies
                gameState.cookies -= upgrade.cost;
                
                // Handle cookies per click upgrade effects
                if (upgrade.effect.cookiesPerClick) {
                    gameState.cookiesPerClick += upgrade.effect.cookiesPerClick;
                    console.log("New cookies per click:", gameState.cookiesPerClick);
                }
                
                // Handle auto-click upgrade effects
                if (upgrade.effect.autoClick) {
                    // Accumulate auto click speed so that multiple upgrades add together
                    gameState.autoClickSpeed = (gameState.autoClickSpeed || 0) + upgrade.effect.autoClick;
                    
                    // Start auto-click interval if not already running
                    if (!window.autoClickerInterval) {
                        // Use a 200ms interval to align with the bounce animation timing
                        window.autoClickerInterval = setInterval(() => {
                            // Calculate auto clicks for this 200ms interval
                            const autoClicks = gameState.autoClickSpeed * 0.2; 
                            gameState.cookies += autoClicks * gameState.cookiesPerClick;
                            updateCookieCounter();
                            
                            // Accumulate auto clicks and trigger bounce animations when a whole click is reached
                            gameState.autoClickAccumulator += autoClicks;
                            if (gameState.autoClickAccumulator >= 1) {
                                const bounceCount = Math.floor(gameState.autoClickAccumulator);
                                for (let i = 0; i < bounceCount; i++) {
                                    pokeCookie();
                                    createClickAnimation(gameState.cookiesPerClick);
                                }
                                gameState.autoClickAccumulator -= bounceCount;
                            }
                        }, 200); // Updated interval matching the bounce duration
                    }
                    
                    // Show the auto-click pointer and start its orbit animation if not already running
                    document.getElementById('autoClickerCursor').style.display = 'block';
                    if (!isPointerAnimating) {
                        isPointerAnimating = true;
                        updatePointerPosition();
                    }
                }

                
                // Handle building multiplier upgrade effects
                if (upgrade.effect.buildingMultiplier) {
                    // Multiply the new multiplier with the existing value (default to 1).
                    gameState.buildingMultiplier = (gameState.buildingMultiplier || 1) * upgrade.effect.buildingMultiplier;
                    console.log("New building multiplier:", gameState.buildingMultiplier);
                }

                
                // Mark the upgrade as purchased
                gameState.upgrades[upgradeId].purchased = true;
                
                // Update displays and save the game
                updateCookieCounter();
                initializeUpgrades();
                initializeBuildings();
                showNotification(`Upgrade purchased: ${upgrade.name}`);
                saveGame();
            }
        }



        // Purchase a building
        function purchaseBuilding(buildingId) {
            const building = BUILDINGS.find(b => b.id === buildingId);
            const cost = calculateBuildingCost(buildingId);
            
            if (gameState.cookies >= cost) {
                // Deduct cookies
                gameState.cookies -= cost;
                
                // Increment building count
                gameState.buildings[buildingId].count++;
                
                // Recalculate CPS
                calculateCookiesPerSecond();
                
                // Update displays
                updateCookieCounter();
                initializeBuildings();
                
                // Trigger building-specific animation
                animateBuildingUpdate(buildingId);
                
                // Check for achievements
                checkAchievements();
                
                // Save game
                saveGame();
            }
        }

        // Animate building update
        function animateBuildingUpdate(buildingId) {
            if (buildingId === 'grandma') {
                // Create and animate the grandma element
                const grandmaElem = document.createElement('div');
                grandmaElem.className = 'grandma-animation';
                // Position it over the cookie (center of the pastry container)
                grandmaElem.style.left = '50%';
                grandmaElem.style.top = '50%';
                grandmaElem.style.transform = 'translate(-50%, -50%)';
                cookieClicker.appendChild(grandmaElem);
                // Remove the element after animation completes
                setTimeout(() => { grandmaElem.remove(); }, 1500);
            } else if (buildingId === 'farm') {
                // Add a temporary farm effect to the cookie by changing its background
                const pastryElem = document.querySelector('.pastry');
                pastryElem.classList.add('farm-active');
                setTimeout(() => { pastryElem.classList.remove('farm-active'); }, 1500);
            }
            // Add additional animations for other building types if desired
        }
        
        // Calculate building cost (increases with each purchase)
        function calculateBuildingCost(buildingId) {
            const building = BUILDINGS.find(b => b.id === buildingId);
            const count = gameState.buildings[buildingId].count;
            return Math.floor(building.baseCost * Math.pow(1.15, count));
        }

        // Calculate building production (affected by upgrades)
        function calculateBuildingProduction(buildingId) {
            const building = BUILDINGS.find(b => b.id === buildingId);
            let multiplier = gameState.buildingMultiplier || 1;
            
            // Apply event effects
            activeEvents.forEach(event => {
                if (event.effect.buildingMultiplier) {
                    multiplier *= event.effect.buildingMultiplier;
                }
            });
            
            return building.cookiesPerSecond * multiplier;
        }

        // Calculate total cookies per second
        function calculateCookiesPerSecond() {
            let cps = 0;
            
            // Add production from buildings
            for (const buildingId in gameState.buildings) {
                const building = BUILDINGS.find(b => b.id === buildingId);
                const count = gameState.buildings[buildingId].count;
                cps += calculateBuildingProduction(buildingId) * count;
            }
            
            gameState.cookiesPerSecond = cps;
            return cps;
        }

        // Update cookies per second (called every second)
        function updateCookiesPerSecond() {
            // Remove division since it's now updating once per second
            gameState.cookies += gameState.cookiesPerSecond;
            updateCookieCounter();
        }

        // Update cookie counter display
        function updateCookieCounter() {
            cookieCounter.textContent = `${formatNumber(Math.floor(gameState.cookies))} cookies`;
            cpsCounter.textContent = `${formatNumber(gameState.cookiesPerSecond)} per second`;
            
            // Update buttons (enable/disable based on cookie count)
            updateButtons();
        }

        // Update buttons based on current cookie count
        function updateButtons() {
            // Update upgrade buttons
            UPGRADES.forEach(upgrade => {
                const button = document.getElementById(`upgrade-${upgrade.id}`);
                if (button) {
                    button.disabled = gameState.cookies < upgrade.cost || gameState.upgrades[upgrade.id].purchased;
                }
            });
            
            // Update building buttons
            BUILDINGS.forEach(building => {
                const button = document.getElementById(`building-${building.id}`);
                if (button) {
                    button.disabled = gameState.cookies < calculateBuildingCost(building.id);
                }
            });
        }


        // Format large numbers with commas
        function formatNumber(num) {
            if (num >= 1000000) {
                return (num / 1000000).toFixed(1) + 'M';
            } else if (num >= 1000) {
                return (num / 1000).toFixed(1) + 'K';
            } else {
                return num.toFixed(0);
            }
        }

        // Create click animation
        function createClickAnimation(value) {
            const clickText = document.createElement('div');
            clickText.textContent = '+' + formatNumber(value);
            clickText.style.position = 'absolute';
            clickText.style.left = Math.random() * 100 + 'px';
            clickText.style.top = Math.random() * 100 + 'px';
            clickText.style.color = '#8c5e2b';
            clickText.style.fontWeight = 'bold';
            clickText.style.pointerEvents = 'none';
            clickText.style.animation = 'fadeUp 1s forwards';
            
            cookieClicker.appendChild(clickText);
            
            // Remove after animation completes
            setTimeout(() => {
                clickText.remove();
            }, 1000);
        }


        // Check achievements
        function checkAchievements() {
            let newAchievements = false;

            ACHIEVEMENTS.forEach(achievement => {
                if (gameState.achievements && gameState.achievements.includes(achievement.id)) {
                    return;
                }

                // Now use gameState.totalClicks consistently
                const stateWithClicks = { ...gameState, clicks: gameState.totalClicks }; 

                if (achievement.condition(stateWithClicks)) {
                    if (!gameState.achievements) {
                        gameState.achievements = [];
                    }
                    gameState.achievements.push(achievement.id);
                    showAchievement(achievement.name, achievement.description);
                    saveAchievement(achievement.id);
                    newAchievements = true;
                }
            });

            if (newAchievements) {
                saveGame();
            }
        }

        // Show achievement notification
        function showAchievement(name, description) {
            achievementElement.innerHTML = `
                <strong>Achievement Unlocked: ${name}</strong><br>
                ${description}
            `;
            achievementElement.style.opacity = '1';
            
            // Hide after 5 seconds
            setTimeout(() => {
                achievementElement.style.opacity = '0';
            }, 5000);
        }

        // Show notification
        function showNotification(message) {
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.textContent = message;
            notificationContainer.appendChild(notification);
            
            // Remove after animation completes
            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        // Global object to store the timestamp of the last notification per event id
let lastNotificationTimestamps = {};

        // Improved triggerRandomEvent function with the same local handling
        function triggerRandomEvent() {
            if (Math.random() < 0.2) {
                const event = EVENTS[Math.floor(Math.random() * EVENTS.length)];
                
                // Display event notification without wiping out existing notifications
                const eventElement = document.createElement('div');
                eventElement.className = 'event-notification';
                eventElement.innerHTML = `
                    <strong>${event.name}</strong><br>
                    ${event.description}
                `;
                // Append without clearing the container to allow multiple concurrent notifications
                eventContainer.appendChild(eventElement);
                
                const activeEvent = { ...event, endTime: Date.now() + event.duration };
                activeEvents.push(activeEvent);
                
                // End event after its duration with a callback to remove its notification
                setTimeout(() => {
                    activeEvents = activeEvents.filter(e => e.id !== event.id);
                    // Remove the specific event notification element
                    if (eventContainer.contains(eventElement)) {
                        eventContainer.removeChild(eventElement);
                    }
                    calculateCookiesPerSecond();
                    updateCookieCounter();
                    showNotification(`${event.name} has ended.`);
                }, event.duration);
                
                calculateCookiesPerSecond();
                updateCookieCounter();
                broadcastEvent(event.id);
            }
        }

        // Helper function for retrying operations with exponential backoff
        async function retryOperation(operation, retries = 3, delay = 1000) {
            for (let attempt = 1; attempt <= retries; attempt++) {
                try {
                    return await operation();
                } catch (error) {
                    if (attempt === retries) {
                        throw error;
                    }
                    console.warn(`Attempt ${attempt} failed. Retrying in ${delay}ms...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    delay *= 2; // Exponential backoff
                }
            }
        }

        // Define a simple throttle to avoid saving too frequently.
        let lastSaveTime = 0;
        const SAVE_INTERVAL = 10000; // Minimum 5 seconds between saves

        async function saveGame() {
            const now = Date.now();
            if (now - lastSaveTime < SAVE_INTERVAL) {
                // Throttle save operations
                return;
            }
            lastSaveTime = now;
            
            const saveData = {
                 ...gameState,
                 lastSaved: now
            };
            try {
                await set(ref(database, `players/${gameState.playerId}`), saveData);
                console.log("Game saved successfully");
            } catch (error) {
                console.error("Error saving game:", error);
                // Optionally, schedule a retry or inform the user here.
            }
        }


        // Load game from Firebase (updated to return a promise)
        async function loadGame() {
            try {
                const snapshot = await get(ref(database, `players/${gameState.playerId}`));
                if (snapshot.exists()) {
                    const savedData = snapshot.val();
                    // Merge the saved data with the current game state to retain any new keys.
                    gameState = { ...gameState, ...savedData };
                    updateCookieCounter();
                    initializeUpgrades();
                    initializeBuildings();
                    showNotification("Game loaded successfully!");
                } else {
                    console.log("No saved game found, starting new game");
                }
            } catch (error) {
                console.error("Error loading game:", error);
                showNotification("Failed to load game. Starting new game.");
            }
        }



        // Save achievement to Firebase
        function saveAchievement(achievementId) {
            // Save to achievements leaderboard
            const achievementData = {
                playerId: gameState.playerId,
                playerName: gameState.playerName,
                achievementId: achievementId,
                timestamp: Date.now()
            };
            
            // Push to Firebase achievements collection
            const achievementsRef = ref(database, 'achievements');
            const newAchievementRef = ref(database, `achievements/${gameState.playerId}_${achievementId}`);
            set(newAchievementRef, achievementData)
                .catch((error) => {
                    console.error("Error saving achievement:", error);
                });
        }

        // Broadcast event to other players
        function broadcastEvent(eventId) {
            const eventData = {
                playerId: gameState.playerId,
                playerName: gameState.playerName,
                eventId: eventId,
                timestamp: Date.now()
            };
            
            // Push to Firebase events collection
            const eventsRef = ref(database, 'events');
            const newEventRef = ref(database, `events/${Date.now()}`);
            set(newEventRef, eventData)
                .catch((error) => {
                    console.error("Error broadcasting event:", error);
                });
        }

        // Listen for multiplayer events
        function listenForMultiplayerEvents() {
            // Listen for achievements
            onValue(ref(database, 'achievements'), (snapshot) => {
                if (snapshot.exists()) {
                    const achievements = snapshot.val();
                    
                    // Find recent achievements (last 60 seconds)
                    const recentAchievements = Object.values(achievements)
                        .filter(a => a.playerId !== gameState.playerId && a.timestamp > Date.now() - 60000)
                        .sort((a, b) => b.timestamp - a.timestamp);
                    
                    // Show notifications for recent achievements
                    recentAchievements.forEach(achievement => {
                        const achievementInfo = ACHIEVEMENTS.find(a => a.id === achievement.achievementId);
                        if (achievementInfo) {
                            showNotification(`${achievement.playerName} just unlocked: ${achievementInfo.name}!`);
                        }
                    });
                }
            });
            
            // Improved events listener with debounce to avoid duplicate notifications
            onValue(ref(database, 'events'), (snapshot) => {
                if (snapshot.exists()) {
                    const events = snapshot.val();
                    const currentTime = Date.now();
                    
                    Object.values(events)
                        .filter(e => e.playerId !== gameState.playerId && currentTime - e.timestamp < 10000)
                        .sort((a, b) => b.timestamp - a.timestamp)
                        .forEach(event => {
                            // Check if we already showed a notification for this event id recently (within 5 seconds)
                            if (!lastNotificationTimestamps[event.eventId] || 
                                currentTime - lastNotificationTimestamps[event.eventId] > 5000) {
                                
                                const eventInfo = EVENTS.find(e => e.id === event.eventId);
                                if (eventInfo) {
                                    showNotification(`${event.playerName} just triggered: ${eventInfo.name}!`);
                                    lastNotificationTimestamps[event.eventId] = currentTime;
                                }
                            }
                        });
                }
            });
        }

        // Update leaderboard
        function updateLeaderboard() {
            // Get all players
            get(ref(database, 'players'))
                .then((snapshot) => {
                    if (snapshot.exists()) {
                        const players = snapshot.val();
                        
                        // Convert to array and sort by cookies
                        const playersArray = Object.values(players)
                            .sort((a, b) => b.cookies - a.cookies);
                        
                        // Limit to top 10
                        const topPlayers = playersArray.slice(0, 10);
                        
                        // Update leaderboard display
                        leaderboardContainer.innerHTML = '';
                        
                        topPlayers.forEach((player, index) => {
                            const playerElement = document.createElement('div');
                            playerElement.className = 'leaderboard-item';
                            
                            // Highlight current player
                            if (player.playerId === gameState.playerId) {
                                playerElement.style.backgroundColor = '#ffe8c8';
                            }
                            
                            playerElement.innerHTML = `
                                <span class="leaderboard-rank">#${index + 1}</span>
                                <span class="leaderboard-name">${player.playerName}</span>
                                <span class="leaderboard-cookies">${formatNumber(Math.floor(player.cookies))}</span>
                            `;
                            
                            leaderboardContainer.appendChild(playerElement);
                        });
                    }
                })
                .catch((error) => {
                    console.error("Error updating leaderboard:", error);
                });
        }

        // Start the game when the page loads
        window.addEventListener('load', initGame);
    </script>
</body>
</html>
